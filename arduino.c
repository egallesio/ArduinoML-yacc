/*
 * arduino.c     -- ArduinoML configuration and code generation
 *
 *           Author: Erick Gallesio [eg@unice.fr]
 *    Creation date: 17-Nov-2017 11:13
 * Last file update: 28-Nov-2017 11:01 (eg)
 */

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include "arduino.h"

static int error_detected = 0;     ///< The number of errors while compiling a file
char *input_path = NULL;           ///< Name of the input path or NULL if stdin

void *__must_malloc(size_t sz, const char *func, const char *file, int line);
#define must_malloc(_sz)         (__must_malloc((_sz), __func__, __FILE__, __LINE__))

// ======================================================================
//                              B R I C K S
// ======================================================================
struct arduino_brick {
  char *var;
  enum port_assignment kind;
  int port_number;
  struct arduino_brick *next;
};


/// declare a new brick on port `number`
Brick *make_brick(int number, enum port_assignment kind, char *name) {
  Brick *p = must_malloc(sizeof(Brick));

  p-> var  = name;
  p-> kind = kind;
  p->port_number = number;
  p->next = NULL;
  return p;
}


/// Add a brick to a list of bricks
Brick *add_brick(Brick *list, Brick *b) {
  list->next = b;
  return list;
}


// ======================================================================
//                            T R A N S I T I O N
// ======================================================================
struct arduino_transition {
  char *var_name;
  int sig_value;
  char *state;
};

/// Make a new transition (when `var` is `signal` goto `newstate`
Transition *make_transition(char *var, int signal, char *newstate) {
  Transition *p = must_malloc(sizeof(Transition));

  p->var_name  = var;
  p->sig_value = signal;
  p->state     = newstate;
  return p;
}


// ======================================================================
//                            A C T I O N
// ======================================================================
struct arduino_action {
  char *var_name;
  int sig_value;
  struct arduino_action *next;
};

// Make a new action (setting `var` to `signal`)
Action *make_action(char *var, int signal) {
  Action *p = must_malloc(sizeof(Action));

  p->var_name  = var;
  p->sig_value = signal;
  p->next      = NULL;
  return p;
}

// Add an action to a list of actions
Action *add_action(Action *list, Action *a) {
  list->next = a;
  return list;
}

// ======================================================================
//                            S Τ A Τ E
// ======================================================================
struct arduino_state {
  char *name;
  Action *actions;
  Transition *transition;
  struct arduino_state *next;
};

static State *initial_state = NULL;


State *make_state(char *var, Action *actions, Transition *transition, int initial) {
  State *p = must_malloc(sizeof(State));

  p->name       = var;
  p-> actions   = actions;
  p->transition = transition;
  p->next       = NULL;
  if (initial) initial_state = p;       // Keep a reference on the initial state
  return p;
}

State *add_state(State *list, State *a) {
  list->next = a;
  return list;
}


// ======================================================================
//                      C O D E   P R O D U C T I O N
// ======================================================================
static void emit_header(char *appname) {
  printf("// File generated by ArduinoML (C/yacc/lex) for %s\n"
         "long time = 0;\n"
         "long debounce = 200;\n\n",
         appname);
}

static void emit_bricks(Brick *lst) {
  // Produce variables
  for (Brick *p = lst; p; p = p->next) {
    printf("int %s = %d;\n", p->var, p->port_number);
  }

  // Produce setup() function
  printf("\nvoid setup() {\n");
  for (Brick *p = lst; p; p = p->next) {
    printf("  pinMode(%s, %s);\n", p->var, (p->kind == sensor)? "INPUT": "OUTPUT");
  }
  printf("}\n\n");
}

static void emit_actions(Action *list) {
  for (Action *p = list; p; p = p->next)
    printf("  digitalWrite(%s, %s);\n", p->var_name, p->sig_value ? "HIGH": "LOW");
}

static void emit_transition(char *current_state, Transition *transition) {
  printf("  boolean guard =  millis() - time > debounce;\n");
  printf("  if (digitalRead(%s) == %s && guard) {\n", transition->var_name,
         transition->sig_value? "HIGH": "LOW");
  printf("    time = millis();\n");
  printf("    state_%s();\n", transition->state);
  printf("  } else {\n");
  printf("    state_%s();\n", current_state);
  printf("  }\n");
}

static void emit_states(State *list) {
  for (State *p = list; p; p = p->next) {
    printf("void state_%s() {\n", p->name);
    emit_actions(p->actions);
    emit_transition(p->name, p->transition);
    printf("}\n\n");
  }
}

static void emit_loop(void) {
  printf("void loop() {\n  state_%s();\n}\n", initial_state->name);
}

void emit_code(char *appname, Brick *brick_list, State *state_list) {
  if (! initial_state)
    error_msg("no initial state declared");

  if (error_detected) {
    fprintf(stderr, "**** %d error%s\n", error_detected, (error_detected>1) ? "s": "");
    return;
  }

  // No error ⇒ produce code
  emit_header(appname);
  emit_bricks(brick_list);
  emit_states(state_list);
  emit_loop();
}


// ======================================================================
//                               U T I L S
// ======================================================================

/// Display error message using the GNU conventions
void error_msg(const char *format, ...) {
  extern int yylineno;
  va_list ap;

  if (input_path) fprintf(stderr, "%s:", input_path);
  fprintf(stderr, "%d: ", yylineno);
  va_start(ap, format);  vfprintf(stderr, format, ap);  va_end(ap);
  fprintf(stderr, "\n");

  error_detected += 1;
}

// Allocate memory and die if not possible
void *__must_malloc(size_t sz, const char *func, const char *file, int line) {
  void *res = malloc(sz);
  if (!res) {
    fprintf(stderr, "**** function '%s' cannot allocate memory (in file '%s':%d)\n",
            func, file, line);
    fprintf(stderr, "Abort.\n");
    exit(1);
  }
  return res;
}
